# Algorithms_For_Problem_Solving
Programming Challenges and Solutions for Fun

|   |   |   |   |
|:---:|:---:|:---:|:---:|
|[Count the Islands](#CountTheIslands)|[String of Parentheses](#StringofParentheses)|[Minimum Coins](#Minimum_Coins)|[FindSquare](#FindSquare)|
|[Can you make a palindrome from a given string](#Canyoumakeapalindromefromagivenstring)|[Intersect Area of two Rectangles](#IntersectAreaoftwoRectangles)|[Integer Palindrome Checker](#IntegerPalindromeChecker)| [Stack Using Heap](#StackUsingHeap) |
|[Smallest Sparse Number](#smallestSparseNumber)|  [N<sup>th</sup> Sevenish Number](#Nthsevenishnumber)|[Max & Min](#Max_&_Min)|[Maximum Subarray Sum of a Circular Array](#Maximum_Subarray_Sum_of_a_Circular_Array) |
|[Sherlock and Anagrams](#Sherlock_and_Anagrams)|[Hash Tables: Ransom Note](#Hash_Tables_Ransom_Note)|[Minimum Swaps 2](#Minimum_Swaps_2)|[New Year Chaos](#New_Year_Chaos)|
|[Two Strings](#Two_Strings)|[Array Manipulation](#Array_Manipulation)|[Super Palindromes](Super_Palindromes)|[Moving Robot](Moving_Robot)|
|[Minimum Cost](#Minimum_Cost)|[Min Stack](#Min_Stack)|[Valid Parentheses](#Valid_Parentheses)|[Minimum Number of Swaps to Make the Binary String Alternating](#Minimum_Swaps)|
|[Sum of All Subset XOR Totals](#XOR_Totals)|[Finding Pairs With a Certain Sum](#FindSumPairs)|[Largest Number](#Largest_Number)|[Best Team With No Conflicts](#Best_Team_With_No_Conflicts)|
|[Longer Contiguous Segments of Ones than Zeros](#Ones_than_Zeros)|[Minimum Speed to Arrive on Time](#minSpeedOnTime)|[Smaller Strings](#SmallerStrings)|[Jump Game](#JumpGame)|
|[Top K Frequent Words](#topKFrequent)|[Course Schedule II](#Course_Schedule)|[Redundant Connection](#RedundantConnection)|[Binary Search](#BinarySearch)|
|[Merge Sort](#MergeSort)|[Sqrt(x)](#Sqrt)|[Search for a Range](#searchRange)|[First Bad Version](#firstBadVersion)|
|[Find Peak Element](#findPeakElement)|[Reverse Linked List](#reverseList)|[Swap Nodes in Pairs](#swapPairs)|[Fibonacci Number ](#fib)|
|[Merge Two Sorted Lists](#mergeTwoLists)|[Maximum Depth of Binary Tree](#maxDepth)|[Factorial](#Factorial)|[Climbing Stairs](#climbStairs)|
|[Determine Whether Matrix Can Be Obtained By Rotation](#findRotation)|[Reduction Operations to Make the Array Elements Equal](#reductionOperations)|[Pascal's Triangle II](#PascalTriangle)|[Max Consecutive Ones](#MaxConsecutiveOnes)|
[Squares of a Sorted Array](#sortedSquares)|[Duplicate Zeros](#duplicateZeros)|[Pow(x, n)](#myPow)|[Merge Triplets to Form Target Triplet](#mergeTriplets)|
[Redistribute Characters to Make All Strings Equal](#makeEqual)|[Maximum Number of Removable Characters](#maximumRemovals)|[K-th Symbol in Grammar](#kthGrammar)|[Decode Ways](#numDecodings)|
[Count Sub Islands](#countSubIslands)|[The Number of Full Rounds You Have Played](#numberOfRounds)|[Largest Odd Number in String](#largestOddNumber)|[Minimum Path Sum](#minPathSum)|
[Partition Equal Subset Sum](#canPartition)|[Maximum Product Difference Between Two Pairs](#maxProductDifference)|[Cyclically Rotating a Grid](#rotateGrid)|[Unique Binary Search Trees II](#generateTrees)|
[Find Numbers with Even Number of Digits](#findNumbers)|[Merge Sorted Array](#merge)|[Remove Element](#removeElement)|[Remove Linked List Elements](#removeElements)|
|[Add Minimum Number of Rungs](#addRungs)|[Maximum Number of Words You Can Type](#canBeTypedWords)|[Sum of Digits of String After Convert](#getLucky)|[Remove Duplicates from Sorted Array](#removeDuplicates)|
|[Check If N and Its Double Exist](#checkIfExist)|[Linked List Cycle](#hasCycle)|[Linked List Cycle II](#detectCycle)|[Maximum Number of Weeks for Which You Can Work](#numberOfWeeks)|
|[Check If String Is a Prefix of Array](#isPrefixString)|[Remove Stones to Minimize the Total](#minStoneSum)|[Minimum Number of Swaps to Make the String Balanced](#minSwaps)|[Find the Duplicate Number](#findDuplicate)|
|[Number of Strings That Appear as Substrings in Word](#numOfStrings)|[Array With Elements Not Equal to Average of Neighbors](#rearrangeArray)|[Minimum Non-Zero Product of the Array Elements](#minNonZeroProduct)|[Check Permutation](#checkPermutation)|
|[Minimize the Difference Between Target and Chosen Elements](#minimizeTheDifference)|[Find Greatest Common Divisor of Array](#findGCD)|[Reverse First k Elements of Queue](#reverseKelements)|[Check Permutation](#checkPermutation)|
|[Find the last true](#lastTrue)|[-](#)|[-](#)|[-](#)|
|[-](#)|[-](#)|[-](#)|[-](#)|
---
### N<sup>th</sup> Sevenish Number<a name="Nthsevenishnumber"></a>
#### Challenge : 
Let's define a "sevenish" number to be one which is either a power of 7, or the sum of unique powers of 7. The first few sevenish numbers are 1, 7, 8, 49, and so on. Create an algorithm to find the nth sevenish number.

#### Solutions :
  * [NthSevenish.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/NthSevenish.py)
  
---
### Count the Islands<a name="CountTheIslands"></a>
#### Challenge : 
  Given a matrix of 1s and 0s, return the number of "islands" in the matrix. A 1 represents land and 0 represents water, so an island is a   group of 1s that are neighboring whose perimeter is surrounded by water.
  For example, this matrix has 4 islands.
  1 0 0 0 0  
  0 0 1 1 0  
  0 1 1 0 0  
  0 0 0 0 0  
  1 1 0 0 1  
  1 1 0 0 1

#### Solutions :
  * [CounttheIslands.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/Solutions/CounttheIslands.py)
  * [CounttheIslands2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/Solutions/CountTheIslands2.py)
---
### String of Parentheses<a name="StringofParentheses"></a>
#### Challenge : 
  Given a string of parentheses, write a function to compute the minimum number of parentheses to be removed to make the string valid (i.e. each open parenthesis is eventually closed).
#### Solutions :
  * [StringofParentheses.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/Solutions/StringofParentheses.py)
---
### Minimum Coins<a name="Minimum_Coins"></a>
#### Challenge : 
Find the minimum number of coins required to make n cents.

You can use standard American denominations, that is, 1¢, 5¢, 10¢, and 25¢.
#### Solutions :
  * [MinCoins.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/MinCoins.java)
---
### FindSquare<a name="FindSquare"></a>
#### Challenge : 
Given an N by M matrix consisting only of 1's and 0's, find the largest rectangle containing only 1's and return its area.
#### Solutions :
  * [FindSquare.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/FindSquare.java)
---
### Stack Using Heap<a name="StackUsingHeap"></a>
#### Challenge :
Implement a stack API using only a heap. A stack implements the following methods:

push(item), which adds an element to the stack
pop(), which removes and returns the most recently added element (or throws an error if there is nothing on the stack)
Recall that a heap has the following operations:

push(item), which adds a new key to the heap
pop(), which removes and returns the max value of the heap
#### Solutions :
  * [StackFromHeap.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/StackFromHeap.java)
---
### Can you make a palindrome from a given string<a name="Canyoumakeapalindromefromagivenstring"></a>
#### Challenge :
Given a string, determine whether any permutation of it is a palindrome.
For example, carrace should return true, since it can be rearranged to form racecar, which is a palindrome. daily should return false, since there's no rearrangement that can form a palindrome.
#### Solutions :
  * [CanMakePalindrome.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/CanMakePalindrome.py)
---
### Intersect Area of two Rectangles<a name="IntersectAreaoftwoRectangles"></a>
#### Challenge :
Given two rectangles on a 2D graph, return the area of their intersection. If the rectangles don't intersect, return 0.
For example, given the following rectangles:  
```
{  
    "top_left": (1, 4),  
    "dimensions": (3, 3) # width, height  
}  
and  
{  
    "top_left": (0, 5),  
    "dimensions": (4, 3) # width, height  
}  
return 6. 
``` 
#### Solutions :
  * [RectangleIntersection.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/RectangleIntersection.java)
---
### Integer Palindrome Checker<a name="IntegerPalindromeChecker"></a>
#### Challenge :
Write a program that checks the given integer is a palindrome. For a example, 
121, 888 are palindromes. 678 is not a palindrome.
Do not convert the integer into a string.
#### Solutions :
  * [IntegerPalindrome.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/IntegerPalindrome.java)
---
### Smallest Sparse Number<a name="smallestSparseNumber"></a>
#### Challenge :
We say a number is sparse if there are no adjacent ones in its binary representation. For example, 21 (10101) is sparse, but 22 (10110) is not.
For a given input N, find the smallest sparse number greater than or equal to N.
Do this in faster than O(N log N) time.
#### Solutions :
  * [smallestSparseNumber.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/smallestSparseNumber.py)
---
### Sherlock and Anagrams<a name="Sherlock_and_Anagrams"></a>
#### Challenge :
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/sherlock-and-anagrams/problem)
#### Solutions :
  * [sherlock-and-anagrams.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C%2B%2B/sherlock-and-anagrams.cpp)
---
### Max & Min<a name="Max_&_Min"></a>
#### Challenge :
Given an array of numbers of length N, find both the minimum and maximum using less than 2 * (N - 2) comparisons.
#### Solutions :
  * [maxMinFind235.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/maxMinFind235.py)
---
### Maximum Subarray Sum of a Circular Array<a name="Maximum_Subarray_Sum_of_a_Circular_Array"></a>
#### Challenge :
Given a circular array, compute its maximum subarray sum in O(n) time. A subarray can be empty, and in this case the sum is 0.
For example, given [8, -1, 3, 4], return 15 as we choose the numbers 3, 4, and 8 where the 8 is obtained from wrapping around.
Given [-4, 5, 1, 0], return 6 as we choose the numbers 5 and 1.
#### Solutions :
  * [LargestSubArray.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/LargestSubArray.py)
---
### Hash Tables: Ransom Note<a name="Hash_Tables_Ransom_Note"></a>
#### Challenge :
Harold is a kidnapper who wrote a ransom note, but now he is worried it will be traced back to him through his handwriting. He found a magazine and wants to know if he can cut out whole words from it and use them to create an untraceable replica of his ransom note. The words in his note are case-sensitive and he must use only whole words available in the magazine. He cannot use substrings or concatenation to create the words he needs.

Given the words in the magazine and the words in the ransom note, print Yes if he can replicate his ransom note exactly using whole words from the magazine; otherwise, print No.

For example, the note is "Attack at dawn". The magazine contains only "attack at dawn". The magazine has all the right words, but there's a case mismatch. The answer is "No".  
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/ctci-ransom-note/problem)
#### Solutions :
  * [ctci-ransom-note.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C%2B%2B/ctci-ransom-note.cpp)
---
### Minimum Swaps 2<a name="Minimum_Swaps_2"></a>
#### Challenge :
You are given an unordered array consisting of consecutive integers [1, 2, 3, ..., n] without any duplicates. You are allowed to swap any two elements. You need to find the minimum number of swaps required to sort the array in ascending order.  
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/minimum-swaps-2/problem)
#### Solutions :
  * [minimum-swaps-2.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C%2B%2B/minimum-swaps-2.cpp)
---
### New Year Chaos<a name="New_Year_Chaos"></a>
#### Challenge :
It's New Year's Day and everyone's in line for the Wonderland rollercoaster ride! There are a number of people queued up, and each person wears a sticker indicating their initial position in the queue. Initial positions increment by 1 from 1 at the front of the line to  at the back.

Any person in the queue can bribe the person directly in front of them to swap positions. If two people swap positions, they still wear the same sticker denoting their original places in line. One person can bribe at most two others. For example, if n=8 and person 5 bribes person 4, the queue will look like this: 1,2,3,5,4,6,7,8.

Fascinated by this chaotic queue, you decide you must know the minimum number of bribes that took place to get the queue into its current state!  
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/new-year-chaos/problem)
#### Solutions :
  * [NewYearChaos.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/NewYearChaos.java)
---
### Two Strings<a name="Two_Strings"></a>
#### Challenge :
Given two strings, determine if they share a common substring. A substring may be as small as one character.
For example, the words "a", "and", "art" share the common substring "a". The words "be" and "cat" do not share a substring.  
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/two-strings/problem)
#### Solutions :
  * [TwoStrings.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C%2B%2B/TwoStrings.cpp)
---
### Array Manipulation<a name="Array_Manipulation"></a>
#### Challenge :
Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each of the array element between two given indices, inclusive. Once all operations have been performed, return the maximum value in your array.  
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/crush/problem)
#### Solutions :
  * [Array Manipulation.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C%2B%2B/Array%20Manipulation.cpp)
---
### Super Palindromes<a name="Super_Palindromes"></a>
#### Challenge :
Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome.
Now, given two positive integers L and R, return the number of superpalindromes in the inclusive range [L,R]
#### Solutions :
  * [SuperPalindrome.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/SuperPalindrome.py)
---
### Moving Robot<a name="Moving_Robot"></a>
#### Challenge :
On a infinite plane, a robot initially stands at (0,0) and faces north. The robot can recieve one of three insructions:
'G': go straight 1 unit  
'L': turn 90 degrees to the left    
'R': turn 90 degrees to the right  
The robot performs the instructions given in order, and repeats them forever.  
return true if there exists a circle, in the plane such that the robot never leaves the circle.   
Input: "GGLLGG"  
Ouput: true  
#### Solutions :
  * [IsLooping.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/IsLooping.py)
---

### Minimum Cost<a name="Minimum_Cost"></a>
#### Challenge :
A builder is looking to build a row of N houses that can be of K different colors.
He has a goal of minimizing cost while ensuring that no two neighboring houses are of the same color.
Given an N by K matrix where the nth row and kth column represents the cost to build the nth house with kth color,
return the minimum cost which achieves this goal.
#### Solutions :
  * [LowestCost.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/LowestCost.py)
---

### Min Stack<a name="Min_Stack"></a>
#### Challenge :
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
#### Solutions :
  * [minStack.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minStack.py)
---

### Valid Parentheses<a name="Valid_Parentheses"></a>
#### Challenge :
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
#### Solutions :
  * [ValidParanthesis.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/ValidParanthesis.java)
---

### Minimum Number of Swaps to Make the Binary String Alternating<a name="Minimum_Swaps"></a>
#### Challenge :
Given a binary string s, return the minimum number of character swaps to make it alternating, or -1 if it is impossible.
The string is called alternating if no two adjacent characters are equal. For example, the strings "010" and "1010" are alternating, while the string "0100" is not.
Any two characters may be swapped, even if they are not adjacent.
1 <= s.length <= 1000. 
s[i] is either '0' or '1'.
#### Solutions :
  * [minSwaps.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minSwaps.py)
---


### Sum of All Subset XOR Totals<a name="XOR_Totals"></a>
#### Challenge :
The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.
For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 
Note: Subsets with the same elements should be counted multiple times.
An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.
1 <= nums.length <= 12.
1 <= nums[i] <= 20
#### Solutions :
  * [subsetXORSum.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/subsetXORSum.py)
---

### Finding Pairs With a Certain Sum<a name="FindSumPairs"></a>
#### Challenge :
You are given two integer arrays nums1 and nums2. You are tasked to implement a data structure that supports queries of two types:
Add a positive integer to an element of a given index in the array nums2.
Count the number of pairs (i, j) such that nums1[i] + nums2[j] equals a given value (0 <= i < nums1.length and 0 <= j < nums2.length).
Implement the FindSumPairs class:
FindSumPairs(int[] nums1, int[] nums2) Initializes the FindSumPairs object with two integer arrays nums1 and nums2.
void add(int index, int val) Adds val to nums2[index], i.e., apply nums2[index] += val.
int count(int tot) Returns the number of pairs (i, j) such that nums1[i] + nums2[j] == tot.
#### Solutions :
  * [FindSumPairs.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/FindSumPairs.py)
---


### Largest Number<a name="Largest_Number"></a>
#### Challenge :
Given a list of non-negative integers nums, arrange them such that they form the largest number.
Note: The result may be very large, so you need to return a string instead of an integer.
1 <= nums.length <= 100.
0 <= nums[i] <= 109.
#### Solutions :
  * [Largest_Number.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/Largest_Number.java)
  * [Largest_Number.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/Largest_Number.py)
---

### Best Team With No Conflicts<a name="Best_Team_With_No_Conflicts"></a>
#### Challenge :
You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the sum of scores of all the players in the team.
However, the basketball team is not allowed to have conflicts. A conflict exists if a younger player has a strictly higher score than an older player. A conflict does not occur between players of the same age.
Given two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, return the highest overall score of all possible basketball teams.
#### Solutions :
  * [bestTeamScore.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/bestTeamScore.py)
---

### Longer Contiguous Segments of Ones than Zeros<a name="Ones_than_Zeros"></a>
#### Challenge :
Given a binary string s, return true if the longest contiguous segment of 1s is strictly longer than the longest contiguous segment of 0s in s. Return false otherwise.

For example, in s = "110100010" the longest contiguous segment of 1s has length 2, and the longest contiguous segment of 0s has length 3.
Note that if there are no 0s, then the longest contiguous segment of 0s is considered to have length 0. The same applies if there are no 1s.

Constraints:

1 <= s.length <= 100.

s[i] is either '0' or '1'.
#### Solutions :
  * [checkZeroOnes.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/checkZeroOnes.py)
---

### Minimum Speed to Arrive on Time<a name="minSpeedOnTime"></a>
#### Challenge :
You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.

Each train can only depart at an integer hour, so you may need to wait in between each train ride.

For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.
Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.

Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.
#### Solutions :
  * [minSpeedOnTime.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minSpeedOnTime.py)
---

### Queue Reconstruction by Height<a name="reconstructQueue"></a>
#### Challenge :
You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.

Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).

Constraints:

1 <= people.length <= 2000

0 <= hi <= 106

0 <= ki < people.length

It is guaranteed that the queue can be reconstructed.

#### Solutions :
  * [reconstructQueue.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reconstructQueue.py)
---

### Smaller Strings<a name="SmallerStrings"></a>
#### Challenge :
You are given an integer K and a string S of length N, consisting of lowercase letters from the first K letters of the English alphabet. Find the number of palindrome strings of length N which are lexicographically smaller than S and consist of lowercase letters from the first K letters of the English alphabet.

A string composed of ordered letters a1,a2,…,an is lexicographically smaller than another string of the same length b1,b2,…,bn if ai<bi, where i is the first index where characters differ in the two strings. For example, the following strings are arranged in lexicographically increasing order: aaa, aab, aba, cab.

A palindrome is a string that is the same written forwards and backwards. For example, anna, racecar, aaa and x are all palindromes, while ab, frog and yoyo are not.

As the number of such strings can be very large, print the answer modulo 10^9+7.

#### Solutions :
  * [SmallerStrings.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/SmallerStrings.py)
---

### Jump Game<a name="JumpGame"></a>
#### Challenge :
You are given a 0-indexed binary string s and two integers minJump and maxJump. In the beginning, you are standing at index 0, which is equal to '0'. You can move from index i to index j if the following conditions are fulfilled:

i + minJump <= j <= min(i + maxJump, s.length - 1), and
s[j] == '0'.
Return true if you can reach index s.length - 1 in s, or false otherwise.

Constraints:

2 <= s.length <= 105

s[i] is either '0' or '1'.

s[0] == '0'

1 <= minJump <= maxJump < s.length

#### Solutions :
  * [jumpGame.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/jumpGame.py)
  * [jumpGame_topDownDP.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/jumpGame_topDownDP.py)
  * [jumpGame_bottomUp_DP.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/jumpGame_bottomUp_DP.py)
---


### Top K Frequent Words<a name="topKFrequent"></a>
#### Challenge :
Given a non-empty list of words, return the k most frequent elements.

Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.

#### Solutions :
  * [topKFrequent1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/topKFrequent1.py)
  * [topKFrequent_Heap1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/topKFrequent_Heap1.py)
  * [topKFrequent_Heap2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/topKFrequent_Heap2.py)
  * 
---

### Course Schedule II<a name="Course_Schedule"></a>
#### Challenge :
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.

#### Solutions :
  * [findOrder_1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findOrder_1.py)
  * [findOrder_dfs.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findOrder_dfs.py)
  * [findOrder_dfs2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findOrder_dfs2.py)
  * 
---

### Redundant Connection<a name="RedundantConnection"></a>
#### Challenge :
In this problem, a tree is an undirected graph that is connected and has no cycles.

You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.

Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.

#### Solutions :
  * [findRedundantConnection.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findRedundantConnection.py)
---

### Binary Search<a name="BinarySearch"></a>
#### Challenge :
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.
#### Solutions :
  * [BinarySearch1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/BinarySearch1.py)
---

### Merge Sort<a name="MergeSort"></a>
#### Challenge :
Implement merge sort
#### Solutions :
  * [MergeSort.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/MergeSort.py)
---

### Sqrt(x)<a name="Sqrt"></a>
#### Challenge :
Given a non-negative integer x, compute and return the square root of x.

Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.

Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.
#### Solutions :
  * [sqrtx.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/sqrtx.py)
---

### Search for a Range<a name="searchRange"></a>
#### Challenge :
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.
#### Solutions :
  * [searchRange.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/searchRange.py)
  * [searchRange_BinarySearch.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/searchRange_BinarySearch.py)
---

### First Bad Version<a name="firstBadVersion"></a>
#### Challenge :
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.
#### Solutions :
  * [firstBadVersion.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/firstBadVersion.py)
---

### Find Peak Element<a name="findPeakElement"></a>
#### Challenge :
A peak element is an element that is strictly greater than its neighbors.

Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -∞.

You must write an algorithm that runs in O(log n) time.
#### Solutions :
  * [findPeakElement.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findPeakElement.py)
  * [findPeakElement.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findPeakElement2.py)
---

### Reverse Linked List<a name="reverseList"></a>
#### Challenge :
Given the head of a singly linked list, reverse the list, and return the reversed list.
#### Solutions :
  * [reverseList.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reverseList.py)
---

### Reverse String <a name="reverseString"></a>
#### Challenge :
Write a function that reverses a string. The input string is given as an array of characters s.
#### Solutions :
  * [reverseString.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reverseString.py)
---

### Swap Nodes in Pairs <a name="swapPairs"></a>
#### Challenge :
Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)
#### Solutions :
  * [swapPairs.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/swapPairs.py)
---

### Fibonacci Number <a name="fib"></a>
#### Challenge :
he Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

#### Solutions :
  * [fib.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/fib.py)
---

### Interleaving String <a name="isInterleave"></a>
#### Challenge :
Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.

An interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that:

s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...
Note: a + b is the concatenation of strings a and b.

#### Solutions :
  * [isInterleave.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/isInterleave.py)
  * [isInterleave_rec_1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/isInterleave_rec_1.py)
  * [isInterleave_rec_2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/isInterleave_rec_2.py)
---


### Merge Two Sorted Lists <a name="mergeTwoLists"></a>
#### Challenge :
Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.

Constraints:

The number of nodes in both lists is in the range [0, 50].

-100 <= Node.val <= 100

Both l1 and l2 are sorted in non-decreasing order.
#### Solutions :
  * [mergeTwoLists.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/mergeTwoLists.py)
---


### Maximum Depth of Binary Tree <a name="maxDepth"></a>
#### Challenge :
Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
#### Solutions :
  * [maxDepth.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/maxDepth.py)
---

### Factorial <a name="Factorial"></a>
#### Challenge :
Given an integer N, print the factorial of the N (mod 10^9+7).

Input:
First line contains one integer, T, number of test cases.
Each test case contains one integer, N.

Output:
For each test case you need to print the factorial of N (mod 10^9+7).

Constraints:
1<=T<=10^5
1<=N<=10^5


#### Solutions :
  * [Factorial_DP.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/Factorial_DP.py)
---

### Climbing Stairs <a name="climbStairs"></a>
#### Challenge :
You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?


#### Solutions :
  * [climbStairs_dp.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/climbStairs_DP.py)
  * [climbStairs_recursive.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/climbStairs_recursive.py)
---

### Determine Whether Matrix Can Be Obtained By Rotation <a name="findRotation"></a>
#### Challenge :
Given two n x n binary matrices mat and target, return true if it is possible to make mat equal to target by rotating mat in 90-degree increments, or false otherwise.

#### Solutions :
  * [findRotation.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/climbStairs_DP.py)
---

### Reduction Operations to Make the Array Elements Equal <a name="reductionOperations"></a>
#### Challenge :
Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:

Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.

#### Solutions :
  * [reductionOperations.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reductionOperations.py)
---

### Pascal's Triangle II <a name="PascalTriangle"></a>
#### Challenge :
Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:

Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.

#### Solutions :
  * [getRow_iter.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/getRow_iter.py)
  * [getRow_recursion.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/getRow_recursion.py)
---

### Max Consecutive Ones <a name="MaxConsecutiveOnes"></a>
#### Challenge :
Given a binary array nums, return the maximum number of consecutive 1's in the array.

#### Solutions :
  * [findMaxConsecutiveOnes1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findMaxConsecutiveOnes1.py)
  * [findMaxConsecutiveOnes2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findMaxConsecutiveOnes2.py)
---

### Squares of a Sorted Array <a name="sortedSquares"></a>
#### Challenge :
Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.

Constraints:

1 <= nums.length <= 104

-104 <= nums[i] <= 104

nums is sorted in non-decreasing order.

#### Solutions :
  * [sortedSquares.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/sortedSquares.py)
---


### Duplicate Zeros <a name="duplicateZeros"></a>
#### Challenge :
Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.

Note that elements beyond the length of the original array are not written.

Do the above modifications to the input array in place, do not return anything from your function.

#### Solutions :
  * [duplicateZeros.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/duplicateZeros.py)
---

### Pow(x, n) <a name="myPow"></a>
#### Challenge :
Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).

#### Solutions :
  * [myPow.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/myPow.py)
---

### Merge Triplets to Form Target Triplet <a name="mergeTriplets"></a>
#### Challenge :
A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.

To obtain target, you may apply the following operation on triplets any number of times (possibly zero):

Choose two indices (0-indexed) i and j (i != j) and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)].
For example, if triplets[i] = [2, 5, 3] and triplets[j] = [1, 7, 5], triplets[j] will be updated to [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5].
Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.

#### Solutions :
  * [mergeTriplets.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/mergeTriplets.py)
---

### Redistribute Characters to Make All Strings Equal <a name="makeEqual"></a>
#### Challenge :
You are given an array of strings words (0-indexed).

In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j].

Return true if you can make every string in words equal using any number of operations, and false otherwise.

#### Solutions :
  * [makeEqual.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/makeEqual.py)
---

### Maximum Number of Removable Characters <a name="maximumRemovals"></a>
#### Challenge :
You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed).

You want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence.

Return the maximum k you can choose such that p is still a subsequence of s after the removals.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

#### Solutions :
  * [maximumRemovals.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/maximumRemovals.py)
---

### K-th Symbol in Grammar <a name="kthGrammar"></a>
#### Challenge :
We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.

For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.

#### Solutions :
  * [kthGrammar.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/kthGrammar.py)
---

### Decode Ways <a name="numDecodings"></a>
#### Challenge :
A message containing letters from A-Z can be encoded into numbers using the following mapping:

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, "11106" can be mapped into:

"AAJF" with the grouping (1 1 10 6)
"KJF" with the grouping (11 10 6)
Note that the grouping (1 11 06) is invalid because "06" cannot be mapped into 'F' since "6" is different from "06".

Given a string s containing only digits, return the number of ways to decode it.

The answer is guaranteed to fit in a 32-bit integer.

#### Solutions :
  * [numDecodings_rec.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numDecodings_rec.py)
  * [numDecodings_dp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numDecodings_dp.py)
---

### Minimum Path Sum <a name="minPathSum"></a>
#### Challenge :
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.
Constraints:

m == grid.length

n == grid[i].length

1 <= m, n <= 200

0 <= grid[i][j] <= 100

#### Solutions :
  * [minPathSum.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minPathSum.py)
  * [minPathSum_dp.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minPathSum_dp.py)
---

### Count Sub Islands <a name="countSubIslands"></a>
#### Challenge :
You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.

An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.

Return the number of islands in grid2 that are considered sub-islands.

Constraints:

m == grid1.length == grid2.length

n == grid1[i].length == grid2[i].length

1 <= m, n <= 500

grid1[i][j] and grid2[i][j] are either 0 or 1.

#### Solutions :
  * [countSubIslands.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/countSubIslands.py)
---

### The Number of Full Rounds You Have Played <a name="numberOfRounds"></a>
#### Challenge :
A new online video game has been released, and in this video game, there are 15-minute rounds scheduled every quarter-hour period. This means that at HH:00, HH:15, HH:30 and HH:45, a new round starts, where HH represents an integer number from 00 to 23. A 24-hour clock is used, so the earliest time in the day is 00:00 and the latest is 23:59.

Given two strings startTime and finishTime in the format "HH:MM" representing the exact time you started and finished playing the game, respectively, calculate the number of full rounds that you played during your game session.

For example, if startTime = "05:20" and finishTime = "05:59" this means you played only one full round from 05:30 to 05:45. You did not play the full round from 05:15 to 05:30 because you started after the round began, and you did not play the full round from 05:45 to 06:00 because you stopped before the round ended.
If finishTime is earlier than startTime, this means you have played overnight (from startTime to the midnight and from midnight to finishTime).

Return the number of full rounds that you have played if you had started playing at startTime and finished at finishTime.

Constraints:

startTime and finishTime are in the format HH:MM.

00 <= HH <= 23

00 <= MM <= 59

startTime and finishTime are not equal.

#### Solutions :
  * [numberOfRounds.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numberOfRounds.py)
---

### Largest Odd Number in String <a name="largestOddNumber"></a>
#### Challenge :
You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string "" if no odd integer exists.

A substring is a contiguous sequence of characters within a string.

Constraints:

1 <= num.length <= 10^5

num only consists of digits and does not contain any leading zeros.

#### Solutions :
  * [largestOddNumber.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/largestOddNumber.py)
---

### Partition Equal Subset Sum <a name="canPartition"></a>
#### Challenge :
Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

Constraints:

1 <= nums.length <= 200

1 <= nums[i] <= 100

#### Solutions :
  * [canPartition.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/canPartition.py)
---

### Maximum Product Difference Between Two Pairs <a name="maxProductDifference"></a>
#### Challenge :
The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).

For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.

Return the maximum such product difference.

#### Solutions :
  * [maxProductDifference.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/maxProductDifference.py)
---

### Cyclically Rotating a Grid <a name="rotateGrid"></a>
#### Challenge :
[Read the problem description here](https://leetcode.com/problems/cyclically-rotating-a-grid/)

#### Solutions :
  * [rotateGrid.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/rotateGrid.py)
---

###  Unique Binary Search Trees II <a name="generateTrees"></a>
#### Challenge :
Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.

[Read the problem description here](https://leetcode.com/problems/unique-binary-search-trees-ii/)

#### Solutions :
  * [generateTrees.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/generateTrees.py)
---

###  Find Numbers with Even Number of Digits <a name="findNumbers"></a>
#### Challenge :
Given an array nums of integers, return how many of them contain an even number of digits.

#### Solutions :
  * [findNumbers.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findNumbers.py)
---

###  Merge Sorted Array <a name="merge"></a>
#### Challenge :
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

#### Solutions :
  * [merge.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/merge.py)
---

###  Remove Element <a name="removeElement"></a>
#### Challenge :
Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

#### Solutions :
  * [removeElement.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/removeElement.py)
---

###  Remove Linked List Elements <a name="removeElements"></a>
#### Challenge :
Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.

#### Solutions :
  * [removeElements.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/removeElements.py)
---

###  Add Minimum Number of Rungs <a name="addRungs"></a>
#### Challenge :
You are given a strictly increasing integer array rungs that represents the height of rungs on a ladder. You are currently on the floor at height 0, and you want to reach the last rung.

You are also given an integer dist. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is at most dist. You are able to insert rungs at any positive integer height if a rung is not already there.

Return the minimum number of rungs that must be added to the ladder in order for you to climb to the last rung.

#### Solutions :
  * [addRungs.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/addRungs.py)
---

###  Maximum Number of Words You Can Type <a name="canBeTypedWords"></a>
#### Challenge :
There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.

Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard.

#### Solutions :
  * [canBeTypedWords.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/canBeTypedWords.py)
---

###  Sum of Digits of String After Convert <a name="getLucky"></a>
#### Challenge :
You are given a string s consisting of lowercase English letters, and an integer k.

First, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z' with 26). Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total.

For example, if s = "zbax" and k = 2, then the resulting integer would be 8 by the following operations:

Convert: "zbax" ➝ "(26)(2)(1)(24)" ➝ "262124" ➝ 262124
Transform #1: 262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17
Transform #2: 17 ➝ 1 + 7 ➝ 8
Return the resulting integer after performing the operations described above.

#### Solutions :
  * [getLucky.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/getLucky.py)
---

###  Remove Duplicates from Sorted Array <a name="removeDuplicates"></a>
#### Challenge :
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

#### Solutions :
  * [removeDuplicates.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/removeDuplicates.py)
---

###  Check If N and Its Double Exist <a name="checkIfExist"></a>
#### Challenge :
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

#### Solutions :
  * [checkIfExist.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/checkIfExist.py)
  * [checkIfExist1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/checkIfExist1.py)
---

###  Linked List Cycle II <a name="detectCycle"></a>
#### Challenge :
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Notice that you should not modify the linked list.

 
#### Solutions :
  * [detectCycle1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/detectCycle1.py)
  * [detectCycle2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/detectCycle2.py)
---

###  Linked List Cycle <a name="hasCycle"></a>
#### Challenge :
Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Return true if there is a cycle in the linked list. Otherwise, return false.
#### Solutions :
  * [hasCycle1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/hasCycle1.py)
  * [hasCycle2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/hasCycle2.py)
---

###  Maximum Number of Weeks for Which You Can Work <a name="numberOfWeeks"></a>
#### Challenge :
There are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has.

You can work on the projects following these two rules:

Every week, you will finish exactly one milestone of one project. You must work every week.
You cannot work on two milestones from the same project for two consecutive weeks.
Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. Note that you may not be able to finish every project's milestones due to these constraints.

Return the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above.
#### Solutions :
  * [numberOfWeeks1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numberOfWeeks1.py)
  * [numberOfWeeks2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numberOfWeeks2.py)
  * [numberOfWeeks3.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numberOfWeeks3.py)
---

###  Check If String Is a Prefix of Array <a name="isPrefixString"></a>
#### Challenge :
Given a string s and an array of strings words, determine whether s is a prefix string of words.

A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length.

Return true if s is a prefix string of words, or false otherwise.
#### Solutions :
  * [isPrefixString1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/isPrefixString1.py)
  * [isPrefixString2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/isPrefixString2.py)
  * [isPrefixString3.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/isPrefixString3.cpp)
---

###  Remove Stones to Minimize the Total <a name="minStoneSum"></a>
#### Challenge :
You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:

Choose any piles[i] and remove floor(piles[i] / 2) stones from it.
Notice that you can apply the operation on the same pile more than once.

Return the minimum possible total number of stones remaining after applying the k operations.

floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).
#### Solutions :
  * [minStoneSum1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minStoneSum1.py)
  * [minStoneSum2.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/minStoneSum2.cpp)
---

###  Minimum Number of Swaps to Make the String Balanced <a name="minSwaps"></a>
#### Challenge :
You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.

A string is called balanced if and only if:

It is the empty string, or
It can be written as AB, where both A and B are balanced strings, or
It can be written as [C], where C is a balanced string.
You may swap the brackets at any two indices any number of times.

Return the minimum number of swaps to make s balanced.
#### Solutions :
  * [minSwaps1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minSwaps1.py)
  * [minSwaps2.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/minSwaps2.cpp)
---

###  Find the Duplicate Number <a name="findDuplicate"></a>
#### Challenge :
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.

You must solve the problem without modifying the array nums and uses only constant extra space.
#### Solutions :
  * [findDuplicate1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minSwaps1.py)
  * [findDuplicate2.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/findDuplicate2.cpp)
  * [findDuplicate3.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/findDuplicate3.cpp)
  * [findDuplicate4.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/findDuplicate4.cpp)
---

###  Number of Strings That Appear as Substrings in Word <a name="numOfStrings"></a>
#### Challenge :
Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word.

A substring is a contiguous sequence of characters within a string.
#### Solutions :
  * [numOfStrings.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numOfStrings.py)
  * [numOfStrings.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/numOfStrings.cpp)
---

###  Array With Elements Not Equal to Average of Neighbors <a name="rearrangeArray"></a>
#### Challenge :
ou are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.

More formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].

Return any rearrangement of nums that meets the requirements.
#### Solutions :
  * [rearrangeArray.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/rearrangeArray.py)
---

###  Minimum Non-Zero Product of the Array Elements <a name="minNonZeroProduct"></a>
#### Challenge :
You are given a positive integer p. Consider an array nums (1-indexed) that consists of the integers in the inclusive range [1, 2p - 1] in their binary representations. You are allowed to do the following operation any number of times:

Choose two elements x and y from nums.
Choose a bit in x and swap it with its corresponding bit in y. Corresponding bit refers to the bit that is in the same position in the other integer.
For example, if x = 1101 and y = 0011, after swapping the 2nd bit from the right, we have x = 1111 and y = 0001.

Find the minimum non-zero product of nums after performing the above operation any number of times. Return this product modulo 109 + 7.

Note: The answer should be the minimum product before the modulo operation is done.
#### Solutions :
  * [minNonZeroProduct.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minNonZeroProduct.py)
---

###  Check Permutation <a name="checkPermutation"></a>
#### Challenge :
Given two strings, write a method to decide if one is a permutation of the
other.
#### Solutions :
  * [CheckPermutation.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/CheckPermutation.py)
  * [CheckPermutation.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++\checkPermutation.cpp)
---

###  Minimize the Difference Between Target and Chosen Elements <a name="minimizeTheDifference"></a>
#### Challenge :
You are given an m x n integer matrix mat and an integer target.

Choose one integer from each row in the matrix such that the absolute difference between target and the sum of the chosen elements is minimized.

Return the minimum absolute difference.

The absolute difference between two numbers a and b is the absolute value of a - b.
#### Solutions :
  * [minimizeTheDifference.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minimizeTheDifference.py)
---

###  Find Greatest Common Divisor of Array <a name="findGCD"></a>
#### Challenge :
Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.

The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.
#### Solutions :
  * [findGCD.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findGCD.py)
---

###   Find Unique Binary String <a name="findDifferentBinaryString"></a>
#### Challenge :
Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.
#### Solutions :
  * [findDifferentBinaryString.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findDifferentBinaryString.py)
---

###   Reverse First k Elements of Queue <a name="reverseKelements"></a>
#### Challenge :
Reverse First k Elements of Queue
#### Solutions :
  * [reverseKElements.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reverseKElements.py)
  * [reverseKElements.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/reverseKElements.cpp)
---

###   Reverse First k Elements of Queue <a name="reverseKelements"></a>
#### Challenge :
Reverse First k Elements of Queue
#### Solutions :
  * [reverseKElements.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reverseKElements.py)
  * [reverseKElements.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/reverseKElements.cpp)
---

###   Check Permutation <a name="checkPermutation"></a>
#### Challenge :
Given two strings, write a method to decide if one is a permutation of the
other.
#### Solutions :
  * [CheckPermutation.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/CheckPermutation.py)
---

###   Find the last true <a name="lastTrue"></a>
#### Challenge :
Find the last true in a binary array using binary search

#### Solutions :
  * [lastTrue.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/lastTrue.py)
---
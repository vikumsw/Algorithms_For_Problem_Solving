# Algorithms_For_Problem_Solving
Programming Challenges and Solutions for Fun

|   |   |   |   |
|:---:|:---:|:---:|:---:|
|[Count the Islands](#CountTheIslands)|[String of Parentheses](#StringofParentheses)|[Minimum Coins](#Minimum_Coins)|[FindSquare](#FindSquare)|
|[Can you make a palindrome from a given string](#Canyoumakeapalindromefromagivenstring)|[Intersect Area of two Rectangles](#IntersectAreaoftwoRectangles)|[Integer Palindrome Checker](#IntegerPalindromeChecker)| [Stack Using Heap](#StackUsingHeap) |
|[Smallest Sparse Number](#smallestSparseNumber)|  [N<sup>th</sup> Sevenish Number](#Nthsevenishnumber)|[Max & Min](#Max_&_Min)|[Maximum Subarray Sum of a Circular Array](#Maximum_Subarray_Sum_of_a_Circular_Array) |
|[Sherlock and Anagrams](#Sherlock_and_Anagrams)|[Hash Tables: Ransom Note](#Hash_Tables_Ransom_Note)|[Minimum Swaps 2](#Minimum_Swaps_2)|[New Year Chaos](#New_Year_Chaos)|
|[Two Strings](#Two_Strings)|[Array Manipulation](#Array_Manipulation)|[Super Palindromes](Super_Palindromes)|[Moving Robot](Moving_Robot)|
|[Minimum Cost](#Minimum_Cost)|[Min Stack](#Min_Stack)|[Valid Parentheses](#Valid_Parentheses)|[Minimum Number of Swaps to Make the Binary String Alternating](#Minimum_Swaps)|
|[Sum of All Subset XOR Totals](#XOR_Totals)|[Finding Pairs With a Certain Sum](#FindSumPairs)|[Largest Number](#Largest_Number)|[Best Team With No Conflicts](#Best_Team_With_No_Conflicts)|
|[Longer Contiguous Segments of Ones than Zeros](#Ones_than_Zeros)|[Minimum Speed to Arrive on Time](#minSpeedOnTime)|[Smaller Strings](#SmallerStrings)|[Jump Game](#JumpGame)|
|[Top K Frequent Words](#topKFrequent)|[Course Schedule II](#Course_Schedule)|[Redundant Connection](#RedundantConnection)|[Binary Search](#BinarySearch)|
|[Merge Sort](#MergeSort)|[Sqrt(x)](#Sqrt)|[Search for a Range](#searchRange)|[First Bad Version](#firstBadVersion)|
|[Find Peak Element](#findPeakElement)|[Reverse Linked List](#reverseList)|[Swap Nodes in Pairs](#swapPairs)|[Fibonacci Number ](#fib)|
|[Merge Two Sorted Lists](#mergeTwoLists)|[Maximum Depth of Binary Tree](#maxDepth)|[Factorial](#Factorial)|[Climbing Stairs](#climbStairs)|
|[Determine Whether Matrix Can Be Obtained By Rotation](#findRotation)|[Reduction Operations to Make the Array Elements Equal](#reductionOperations)|[Pascal's Triangle II](#PascalTriangle)|[Max Consecutive Ones](#MaxConsecutiveOnes)|
[Squares of a Sorted Array](#sortedSquares)|[Duplicate Zeros](#duplicateZeros)|[Pow(x, n)](#myPow)|[Merge Triplets to Form Target Triplet](#mergeTriplets)|
[Redistribute Characters to Make All Strings Equal](#makeEqual)|[Maximum Number of Removable Characters](#maximumRemovals)|[K-th Symbol in Grammar](#kthGrammar)|[Decode Ways](#numDecodings)|
[Count Sub Islands](#countSubIslands)|[The Number of Full Rounds You Have Played](#numberOfRounds)|[Largest Odd Number in String](#largestOddNumber)|[Minimum Path Sum](#minPathSum)|
[Partition Equal Subset Sum](#canPartition)|[Maximum Product Difference Between Two Pairs](#maxProductDifference)|[Cyclically Rotating a Grid](#rotateGrid)|[Unique Binary Search Trees II](#generateTrees)|
[Find Numbers with Even Number of Digits](#findNumbers)|[Merge Sorted Array](#merge)|[Remove Element](#removeElement)|[Remove Linked List Elements](#removeElements)|
|[Add Minimum Number of Rungs](#addRungs)|[Maximum Number of Words You Can Type](#canBeTypedWords)|[Sum of Digits of String After Convert](#getLucky)|[Remove Duplicates from Sorted Array](#removeDuplicates)|
|[Check If N and Its Double Exist](#checkIfExist)|[Linked List Cycle](#hasCycle)|[Linked List Cycle II](#detectCycle)|[Maximum Number of Weeks for Which You Can Work](#numberOfWeeks)|
|[Check If String Is a Prefix of Array](#isPrefixString)|[Remove Stones to Minimize the Total](#minStoneSum)|[Minimum Number of Swaps to Make the String Balanced](#minSwaps)|[Find the Duplicate Number](#findDuplicate)|
|[Number of Strings That Appear as Substrings in Word](#numOfStrings)|[Array With Elements Not Equal to Average of Neighbors](#rearrangeArray)|[Minimum Non-Zero Product of the Array Elements](#minNonZeroProduct)|[Check Permutation](#checkPermutation)|
|[Minimize the Difference Between Target and Chosen Elements](#minimizeTheDifference)|[Find Greatest Common Divisor of Array](#findGCD)|[Reverse First k Elements of Queue](#reverseKelements)|[Check Permutation](#checkPermutation)|
|[Find the last true](#lastTrue)|[Rotate Matrix](#RotateMatrix)|[Zigzag Traversal](#ZigzagTraversal)|[String Compression](#StringCompression)|
|[Reverse the order of words](#Reversewords)|[URLify](#URLify)|[Zero Matrix](#ZeroMatrix)|[Return Kth to Last](#ReturnKth)|
|[Sum Lists](#SumLists)|[Find the Kth Largest Integer in the Array](#kthLargestNumber)|[Minimum Difference Between Highest and Lowest of K Scores](#minimumDifference)|[Minimal Tree](#MinimalTree)|
|[Route Between Nodes](#RouteBetweenNodes)|[Palindrome](#Palindrome)|[Count Special Quadruplets](#countQuadruplets)|[The Number of Weak Characters in the Game](#numberOfWeakCharacters)|
|[Shuffle an Array of Integers](#shuffleArray)|[Maximum Product of the Length of Two Palindromic Subsequences](#maxProduct)|[Final Value of Variable After Performing Operations](#finalValueAfterOperations)|[Sum of Beauty in the Array](#sumOfBeauties)|
|[Detect Squares](#DetectSquares)|[Maximum Difference Between Increasing Elements](#maximumDifference)|[Grid Game](#gridGame)|[Check if Numbers Are Ascending in a Sentence](#areNumbersAscending)|
|[Count Number of Maximum Bitwise-OR Subsets](#countMaxOrSubsets)|[Simple Bank System](#SimpleBankSystem)|[Number of Valid Words in a Sentence](#countValidWords)|[Next Greater Numerically Balanced Number](#nextBeautifulNumber)|
|[Check if an Original String Exists Given Two Encoded Strings](#)|[-](#)|[-](#)|[-](#)|
|[-](#possiblyEquals)|[Minimum Operations to Convert Number](#minimumOperations)|[Find the Minimum and Maximum Number of Nodes Between Critical Points](#nodesBetweenCriticalPoints)|[Smallest Index With Equal Value](#smallestEqual)|
|[Find Smallest Letter Greater Than Target](#isPerfectSquare)|[Find Smallest Letter Greater Than Target](#nextGreatestLetter)|[Path Sum](#hasPathSum)|[Deepest Leaves Sum](#deepestLeavesSum)|
|[Dogs and Cats](#dogs_and_cats)|[-](#)|[-](#)|[-](#)|
|[-](#)|[-](#)|[-](#)|[-](#)|
### linked lists Intersection <a name="linkedlistsIntersection"></a>
---
### N<sup>th</sup> Sevenish Number<a name="Nthsevenishnumber"></a>
#### Challenge : 
Let's define a "sevenish" number to be one which is either a power of 7, or the sum of unique powers of 7. The first few sevenish numbers are 1, 7, 8, 49, and so on. Create an algorithm to find the nth sevenish number.

#### Solutions :
  * [NthSevenish.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/NthSevenish.py)
  
---
### Count the Islands<a name="CountTheIslands"></a>
#### Challenge : 
  Given a matrix of 1s and 0s, return the number of "islands" in the matrix. A 1 represents land and 0 represents water, so an island is a   group of 1s that are neighboring whose perimeter is surrounded by water.
  For example, this matrix has 4 islands.
  1 0 0 0 0  
  0 0 1 1 0  
  0 1 1 0 0  
  0 0 0 0 0  
  1 1 0 0 1  
  1 1 0 0 1

#### Solutions :
  * [CounttheIslands.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/Solutions/CounttheIslands.py)
  * [CounttheIslands2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/Solutions/CountTheIslands2.py)
---
### String of Parentheses<a name="StringofParentheses"></a>
#### Challenge : 
  Given a string of parentheses, write a function to compute the minimum number of parentheses to be removed to make the string valid (i.e. each open parenthesis is eventually closed).
#### Solutions :
  * [StringofParentheses.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/Solutions/StringofParentheses.py)
---
### Minimum Coins<a name="Minimum_Coins"></a>
#### Challenge : 
Find the minimum number of coins required to make n cents.

You can use standard American denominations, that is, 1¢, 5¢, 10¢, and 25¢.
#### Solutions :
  * [MinCoins.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/MinCoins.java)
---
### FindSquare<a name="FindSquare"></a>
#### Challenge : 
Given an N by M matrix consisting only of 1's and 0's, find the largest rectangle containing only 1's and return its area.
#### Solutions :
  * [FindSquare.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/FindSquare.java)
---
### Stack Using Heap<a name="StackUsingHeap"></a>
#### Challenge :
Implement a stack API using only a heap. A stack implements the following methods:

push(item), which adds an element to the stack
pop(), which removes and returns the most recently added element (or throws an error if there is nothing on the stack)
Recall that a heap has the following operations:

push(item), which adds a new key to the heap
pop(), which removes and returns the max value of the heap
#### Solutions :
  * [StackFromHeap.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/StackFromHeap.java)
---
### Can you make a palindrome from a given string<a name="Canyoumakeapalindromefromagivenstring"></a>
#### Challenge :
Given a string, determine whether any permutation of it is a palindrome.
For example, carrace should return true, since it can be rearranged to form racecar, which is a palindrome. daily should return false, since there's no rearrangement that can form a palindrome.
#### Solutions :
  * [CanMakePalindrome.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/CanMakePalindrome.py)
---
### Intersect Area of two Rectangles<a name="IntersectAreaoftwoRectangles"></a>
#### Challenge :
Given two rectangles on a 2D graph, return the area of their intersection. If the rectangles don't intersect, return 0.
For example, given the following rectangles:  
```
{  
    "top_left": (1, 4),  
    "dimensions": (3, 3) # width, height  
}  
and  
{  
    "top_left": (0, 5),  
    "dimensions": (4, 3) # width, height  
}  
return 6. 
``` 
#### Solutions :
  * [RectangleIntersection.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/RectangleIntersection.java)
---
### Integer Palindrome Checker<a name="IntegerPalindromeChecker"></a>
#### Challenge :
Write a program that checks the given integer is a palindrome. For a example, 
121, 888 are palindromes. 678 is not a palindrome.
Do not convert the integer into a string.
#### Solutions :
  * [IntegerPalindrome.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/IntegerPalindrome.java)
---
### Smallest Sparse Number<a name="smallestSparseNumber"></a>
#### Challenge :
We say a number is sparse if there are no adjacent ones in its binary representation. For example, 21 (10101) is sparse, but 22 (10110) is not.
For a given input N, find the smallest sparse number greater than or equal to N.
Do this in faster than O(N log N) time.
#### Solutions :
  * [smallestSparseNumber.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/smallestSparseNumber.py)
---
### Sherlock and Anagrams<a name="Sherlock_and_Anagrams"></a>
#### Challenge :
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/sherlock-and-anagrams/problem)
#### Solutions :
  * [sherlock-and-anagrams.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C%2B%2B/sherlock-and-anagrams.cpp)
---
### Max & Min<a name="Max_&_Min"></a>
#### Challenge :
Given an array of numbers of length N, find both the minimum and maximum using less than 2 * (N - 2) comparisons.
#### Solutions :
  * [maxMinFind235.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/maxMinFind235.py)
---
### Maximum Subarray Sum of a Circular Array<a name="Maximum_Subarray_Sum_of_a_Circular_Array"></a>
#### Challenge :
Given a circular array, compute its maximum subarray sum in O(n) time. A subarray can be empty, and in this case the sum is 0.
For example, given [8, -1, 3, 4], return 15 as we choose the numbers 3, 4, and 8 where the 8 is obtained from wrapping around.
Given [-4, 5, 1, 0], return 6 as we choose the numbers 5 and 1.
#### Solutions :
  * [LargestSubArray.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/LargestSubArray.py)
---
### Hash Tables: Ransom Note<a name="Hash_Tables_Ransom_Note"></a>
#### Challenge :
Harold is a kidnapper who wrote a ransom note, but now he is worried it will be traced back to him through his handwriting. He found a magazine and wants to know if he can cut out whole words from it and use them to create an untraceable replica of his ransom note. The words in his note are case-sensitive and he must use only whole words available in the magazine. He cannot use substrings or concatenation to create the words he needs.

Given the words in the magazine and the words in the ransom note, print Yes if he can replicate his ransom note exactly using whole words from the magazine; otherwise, print No.

For example, the note is "Attack at dawn". The magazine contains only "attack at dawn". The magazine has all the right words, but there's a case mismatch. The answer is "No".  
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/ctci-ransom-note/problem)
#### Solutions :
  * [ctci-ransom-note.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C%2B%2B/ctci-ransom-note.cpp)
---
### Minimum Swaps 2<a name="Minimum_Swaps_2"></a>
#### Challenge :
You are given an unordered array consisting of consecutive integers [1, 2, 3, ..., n] without any duplicates. You are allowed to swap any two elements. You need to find the minimum number of swaps required to sort the array in ascending order.  
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/minimum-swaps-2/problem)
#### Solutions :
  * [minimum-swaps-2.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C%2B%2B/minimum-swaps-2.cpp)
---
### New Year Chaos<a name="New_Year_Chaos"></a>
#### Challenge :
It's New Year's Day and everyone's in line for the Wonderland rollercoaster ride! There are a number of people queued up, and each person wears a sticker indicating their initial position in the queue. Initial positions increment by 1 from 1 at the front of the line to  at the back.

Any person in the queue can bribe the person directly in front of them to swap positions. If two people swap positions, they still wear the same sticker denoting their original places in line. One person can bribe at most two others. For example, if n=8 and person 5 bribes person 4, the queue will look like this: 1,2,3,5,4,6,7,8.

Fascinated by this chaotic queue, you decide you must know the minimum number of bribes that took place to get the queue into its current state!  
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/new-year-chaos/problem)
#### Solutions :
  * [NewYearChaos.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/NewYearChaos.java)
---
### Two Strings<a name="Two_Strings"></a>
#### Challenge :
Given two strings, determine if they share a common substring. A substring may be as small as one character.
For example, the words "a", "and", "art" share the common substring "a". The words "be" and "cat" do not share a substring.  
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/two-strings/problem)
#### Solutions :
  * [TwoStrings.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C%2B%2B/TwoStrings.cpp)
---
### Array Manipulation<a name="Array_Manipulation"></a>
#### Challenge :
Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each of the array element between two given indices, inclusive. Once all operations have been performed, return the maximum value in your array.  
[Read the problem in Hacker Rank](https://www.hackerrank.com/challenges/crush/problem)
#### Solutions :
  * [Array Manipulation.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C%2B%2B/Array%20Manipulation.cpp)
---
### Super Palindromes<a name="Super_Palindromes"></a>
#### Challenge :
Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome.
Now, given two positive integers L and R, return the number of superpalindromes in the inclusive range [L,R]
#### Solutions :
  * [SuperPalindrome.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/SuperPalindrome.py)
---
### Moving Robot<a name="Moving_Robot"></a>
#### Challenge :
On a infinite plane, a robot initially stands at (0,0) and faces north. The robot can recieve one of three insructions:
'G': go straight 1 unit  
'L': turn 90 degrees to the left    
'R': turn 90 degrees to the right  
The robot performs the instructions given in order, and repeats them forever.  
return true if there exists a circle, in the plane such that the robot never leaves the circle.   
Input: "GGLLGG"  
Ouput: true  
#### Solutions :
  * [IsLooping.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/IsLooping.py)
---

### Minimum Cost<a name="Minimum_Cost"></a>
#### Challenge :
A builder is looking to build a row of N houses that can be of K different colors.
He has a goal of minimizing cost while ensuring that no two neighboring houses are of the same color.
Given an N by K matrix where the nth row and kth column represents the cost to build the nth house with kth color,
return the minimum cost which achieves this goal.
#### Solutions :
  * [LowestCost.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/LowestCost.py)
---

### Min Stack<a name="Min_Stack"></a>
#### Challenge :
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
#### Solutions :
  * [minStack.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minStack.py)
---

### Valid Parentheses<a name="Valid_Parentheses"></a>
#### Challenge :
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
#### Solutions :
  * [ValidParanthesis.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/ValidParanthesis.java)
---

### Minimum Number of Swaps to Make the Binary String Alternating<a name="Minimum_Swaps"></a>
#### Challenge :
Given a binary string s, return the minimum number of character swaps to make it alternating, or -1 if it is impossible.
The string is called alternating if no two adjacent characters are equal. For example, the strings "010" and "1010" are alternating, while the string "0100" is not.
Any two characters may be swapped, even if they are not adjacent.
1 <= s.length <= 1000. 
s[i] is either '0' or '1'.
#### Solutions :
  * [minSwaps.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minSwaps.py)
---


### Sum of All Subset XOR Totals<a name="XOR_Totals"></a>
#### Challenge :
The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.
For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 
Note: Subsets with the same elements should be counted multiple times.
An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.
1 <= nums.length <= 12.
1 <= nums[i] <= 20
#### Solutions :
  * [subsetXORSum.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/subsetXORSum.py)
---

### Finding Pairs With a Certain Sum<a name="FindSumPairs"></a>
#### Challenge :
You are given two integer arrays nums1 and nums2. You are tasked to implement a data structure that supports queries of two types:
Add a positive integer to an element of a given index in the array nums2.
Count the number of pairs (i, j) such that nums1[i] + nums2[j] equals a given value (0 <= i < nums1.length and 0 <= j < nums2.length).
Implement the FindSumPairs class:
FindSumPairs(int[] nums1, int[] nums2) Initializes the FindSumPairs object with two integer arrays nums1 and nums2.
void add(int index, int val) Adds val to nums2[index], i.e., apply nums2[index] += val.
int count(int tot) Returns the number of pairs (i, j) such that nums1[i] + nums2[j] == tot.
#### Solutions :
  * [FindSumPairs.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/FindSumPairs.py)
---


### Largest Number<a name="Largest_Number"></a>
#### Challenge :
Given a list of non-negative integers nums, arrange them such that they form the largest number.
Note: The result may be very large, so you need to return a string instead of an integer.
1 <= nums.length <= 100.
0 <= nums[i] <= 109.
#### Solutions :
  * [Largest_Number.java](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/java/Largest_Number.java)
  * [Largest_Number.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/Largest_Number.py)
---

### Best Team With No Conflicts<a name="Best_Team_With_No_Conflicts"></a>
#### Challenge :
You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the sum of scores of all the players in the team.
However, the basketball team is not allowed to have conflicts. A conflict exists if a younger player has a strictly higher score than an older player. A conflict does not occur between players of the same age.
Given two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, return the highest overall score of all possible basketball teams.
#### Solutions :
  * [bestTeamScore.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/bestTeamScore.py)
---

### Longer Contiguous Segments of Ones than Zeros<a name="Ones_than_Zeros"></a>
#### Challenge :
Given a binary string s, return true if the longest contiguous segment of 1s is strictly longer than the longest contiguous segment of 0s in s. Return false otherwise.

For example, in s = "110100010" the longest contiguous segment of 1s has length 2, and the longest contiguous segment of 0s has length 3.
Note that if there are no 0s, then the longest contiguous segment of 0s is considered to have length 0. The same applies if there are no 1s.

Constraints:

1 <= s.length <= 100.

s[i] is either '0' or '1'.
#### Solutions :
  * [checkZeroOnes.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/checkZeroOnes.py)
---

### Minimum Speed to Arrive on Time<a name="minSpeedOnTime"></a>
#### Challenge :
You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.

Each train can only depart at an integer hour, so you may need to wait in between each train ride.

For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.
Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.

Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.
#### Solutions :
  * [minSpeedOnTime.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minSpeedOnTime.py)
---

### Queue Reconstruction by Height<a name="reconstructQueue"></a>
#### Challenge :
You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.

Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).

Constraints:

1 <= people.length <= 2000

0 <= hi <= 106

0 <= ki < people.length

It is guaranteed that the queue can be reconstructed.

#### Solutions :
  * [reconstructQueue.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reconstructQueue.py)
---

### Smaller Strings<a name="SmallerStrings"></a>
#### Challenge :
You are given an integer K and a string S of length N, consisting of lowercase letters from the first K letters of the English alphabet. Find the number of palindrome strings of length N which are lexicographically smaller than S and consist of lowercase letters from the first K letters of the English alphabet.

A string composed of ordered letters a1,a2,…,an is lexicographically smaller than another string of the same length b1,b2,…,bn if ai<bi, where i is the first index where characters differ in the two strings. For example, the following strings are arranged in lexicographically increasing order: aaa, aab, aba, cab.

A palindrome is a string that is the same written forwards and backwards. For example, anna, racecar, aaa and x are all palindromes, while ab, frog and yoyo are not.

As the number of such strings can be very large, print the answer modulo 10^9+7.

#### Solutions :
  * [SmallerStrings.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/SmallerStrings.py)
---

### Jump Game<a name="JumpGame"></a>
#### Challenge :
You are given a 0-indexed binary string s and two integers minJump and maxJump. In the beginning, you are standing at index 0, which is equal to '0'. You can move from index i to index j if the following conditions are fulfilled:

i + minJump <= j <= min(i + maxJump, s.length - 1), and
s[j] == '0'.
Return true if you can reach index s.length - 1 in s, or false otherwise.

Constraints:

2 <= s.length <= 105

s[i] is either '0' or '1'.

s[0] == '0'

1 <= minJump <= maxJump < s.length

#### Solutions :
  * [jumpGame.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/jumpGame.py)
  * [jumpGame_topDownDP.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/jumpGame_topDownDP.py)
  * [jumpGame_bottomUp_DP.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/jumpGame_bottomUp_DP.py)
---


### Top K Frequent Words<a name="topKFrequent"></a>
#### Challenge :
Given a non-empty list of words, return the k most frequent elements.

Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.

#### Solutions :
  * [topKFrequent1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/topKFrequent1.py)
  * [topKFrequent_Heap1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/topKFrequent_Heap1.py)
  * [topKFrequent_Heap2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/topKFrequent_Heap2.py)
  * 
---

### Course Schedule II<a name="Course_Schedule"></a>
#### Challenge :
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.

#### Solutions :
  * [findOrder_1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findOrder_1.py)
  * [findOrder_dfs.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findOrder_dfs.py)
  * [findOrder_dfs2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findOrder_dfs2.py)
  * 
---

### Redundant Connection<a name="RedundantConnection"></a>
#### Challenge :
In this problem, a tree is an undirected graph that is connected and has no cycles.

You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.

Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.

#### Solutions :
  * [findRedundantConnection.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findRedundantConnection.py)
---

### Binary Search<a name="BinarySearch"></a>
#### Challenge :
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.
#### Solutions :
  * [BinarySearch1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/BinarySearch1.py)
---

### Merge Sort<a name="MergeSort"></a>
#### Challenge :
Implement merge sort
#### Solutions :
  * [MergeSort.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/MergeSort.py)
---

### Sqrt(x)<a name="Sqrt"></a>
#### Challenge :
Given a non-negative integer x, compute and return the square root of x.

Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.

Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.
#### Solutions :
  * [sqrtx.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/sqrtx.py)
---

### Search for a Range<a name="searchRange"></a>
#### Challenge :
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.
#### Solutions :
  * [searchRange.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/searchRange.py)
  * [searchRange_BinarySearch.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/searchRange_BinarySearch.py)
---

### First Bad Version<a name="firstBadVersion"></a>
#### Challenge :
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.
#### Solutions :
  * [firstBadVersion.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/firstBadVersion.py)
---

### Find Peak Element<a name="findPeakElement"></a>
#### Challenge :
A peak element is an element that is strictly greater than its neighbors.

Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -∞.

You must write an algorithm that runs in O(log n) time.
#### Solutions :
  * [findPeakElement.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findPeakElement.py)
  * [findPeakElement.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findPeakElement2.py)
---

### Reverse Linked List<a name="reverseList"></a>
#### Challenge :
Given the head of a singly linked list, reverse the list, and return the reversed list.
#### Solutions :
  * [reverseList.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reverseList.py)
---

### Reverse String <a name="reverseString"></a>
#### Challenge :
Write a function that reverses a string. The input string is given as an array of characters s.
#### Solutions :
  * [reverseString.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reverseString.py)
---

### Swap Nodes in Pairs <a name="swapPairs"></a>
#### Challenge :
Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)
#### Solutions :
  * [swapPairs.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/swapPairs.py)
---

### Fibonacci Number <a name="fib"></a>
#### Challenge :
he Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

#### Solutions :
  * [fib.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/fib.py)
---

### Interleaving String <a name="isInterleave"></a>
#### Challenge :
Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.

An interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that:

s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...
Note: a + b is the concatenation of strings a and b.

#### Solutions :
  * [isInterleave.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/isInterleave.py)
  * [isInterleave_rec_1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/isInterleave_rec_1.py)
  * [isInterleave_rec_2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/isInterleave_rec_2.py)
---


### Merge Two Sorted Lists <a name="mergeTwoLists"></a>
#### Challenge :
Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.

Constraints:

The number of nodes in both lists is in the range [0, 50].

-100 <= Node.val <= 100

Both l1 and l2 are sorted in non-decreasing order.
#### Solutions :
  * [mergeTwoLists.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/mergeTwoLists.py)
---


### Maximum Depth of Binary Tree <a name="maxDepth"></a>
#### Challenge :
Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
#### Solutions :
  * [maxDepth.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/maxDepth.py)
---

### Factorial <a name="Factorial"></a>
#### Challenge :
Given an integer N, print the factorial of the N (mod 10^9+7).

Input:
First line contains one integer, T, number of test cases.
Each test case contains one integer, N.

Output:
For each test case you need to print the factorial of N (mod 10^9+7).

Constraints:
1<=T<=10^5
1<=N<=10^5


#### Solutions :
  * [Factorial_DP.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/Factorial_DP.py)
---

### Climbing Stairs <a name="climbStairs"></a>
#### Challenge :
You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?


#### Solutions :
  * [climbStairs_dp.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/climbStairs_DP.py)
  * [climbStairs_recursive.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/climbStairs_recursive.py)
---

### Determine Whether Matrix Can Be Obtained By Rotation <a name="findRotation"></a>
#### Challenge :
Given two n x n binary matrices mat and target, return true if it is possible to make mat equal to target by rotating mat in 90-degree increments, or false otherwise.

#### Solutions :
  * [findRotation.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/climbStairs_DP.py)
---

### Reduction Operations to Make the Array Elements Equal <a name="reductionOperations"></a>
#### Challenge :
Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:

Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.

#### Solutions :
  * [reductionOperations.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reductionOperations.py)
---

### Pascal's Triangle II <a name="PascalTriangle"></a>
#### Challenge :
Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:

Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.

#### Solutions :
  * [getRow_iter.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/getRow_iter.py)
  * [getRow_recursion.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/getRow_recursion.py)
---

### Max Consecutive Ones <a name="MaxConsecutiveOnes"></a>
#### Challenge :
Given a binary array nums, return the maximum number of consecutive 1's in the array.

#### Solutions :
  * [findMaxConsecutiveOnes1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findMaxConsecutiveOnes1.py)
  * [findMaxConsecutiveOnes2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findMaxConsecutiveOnes2.py)
---

### Squares of a Sorted Array <a name="sortedSquares"></a>
#### Challenge :
Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.

Constraints:

1 <= nums.length <= 104

-104 <= nums[i] <= 104

nums is sorted in non-decreasing order.

#### Solutions :
  * [sortedSquares.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/sortedSquares.py)
---


### Duplicate Zeros <a name="duplicateZeros"></a>
#### Challenge :
Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.

Note that elements beyond the length of the original array are not written.

Do the above modifications to the input array in place, do not return anything from your function.

#### Solutions :
  * [duplicateZeros.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/duplicateZeros.py)
---

### Pow(x, n) <a name="myPow"></a>
#### Challenge :
Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).

#### Solutions :
  * [myPow.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/myPow.py)
---

### Merge Triplets to Form Target Triplet <a name="mergeTriplets"></a>
#### Challenge :
A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.

To obtain target, you may apply the following operation on triplets any number of times (possibly zero):

Choose two indices (0-indexed) i and j (i != j) and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)].
For example, if triplets[i] = [2, 5, 3] and triplets[j] = [1, 7, 5], triplets[j] will be updated to [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5].
Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.

#### Solutions :
  * [mergeTriplets.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/mergeTriplets.py)
---

### Redistribute Characters to Make All Strings Equal <a name="makeEqual"></a>
#### Challenge :
You are given an array of strings words (0-indexed).

In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j].

Return true if you can make every string in words equal using any number of operations, and false otherwise.

#### Solutions :
  * [makeEqual.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/makeEqual.py)
---

### Maximum Number of Removable Characters <a name="maximumRemovals"></a>
#### Challenge :
You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed).

You want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence.

Return the maximum k you can choose such that p is still a subsequence of s after the removals.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

#### Solutions :
  * [maximumRemovals.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/maximumRemovals.py)
---

### K-th Symbol in Grammar <a name="kthGrammar"></a>
#### Challenge :
We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.

For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.

#### Solutions :
  * [kthGrammar.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/kthGrammar.py)
---

### Decode Ways <a name="numDecodings"></a>
#### Challenge :
A message containing letters from A-Z can be encoded into numbers using the following mapping:

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, "11106" can be mapped into:

"AAJF" with the grouping (1 1 10 6)
"KJF" with the grouping (11 10 6)
Note that the grouping (1 11 06) is invalid because "06" cannot be mapped into 'F' since "6" is different from "06".

Given a string s containing only digits, return the number of ways to decode it.

The answer is guaranteed to fit in a 32-bit integer.

#### Solutions :
  * [numDecodings_rec.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numDecodings_rec.py)
  * [numDecodings_dp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numDecodings_dp.py)
---

### Minimum Path Sum <a name="minPathSum"></a>
#### Challenge :
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.
Constraints:

m == grid.length

n == grid[i].length

1 <= m, n <= 200

0 <= grid[i][j] <= 100

#### Solutions :
  * [minPathSum.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minPathSum.py)
  * [minPathSum_dp.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minPathSum_dp.py)
---

### Count Sub Islands <a name="countSubIslands"></a>
#### Challenge :
You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.

An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.

Return the number of islands in grid2 that are considered sub-islands.

Constraints:

m == grid1.length == grid2.length

n == grid1[i].length == grid2[i].length

1 <= m, n <= 500

grid1[i][j] and grid2[i][j] are either 0 or 1.

#### Solutions :
  * [countSubIslands.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/countSubIslands.py)
---

### The Number of Full Rounds You Have Played <a name="numberOfRounds"></a>
#### Challenge :
A new online video game has been released, and in this video game, there are 15-minute rounds scheduled every quarter-hour period. This means that at HH:00, HH:15, HH:30 and HH:45, a new round starts, where HH represents an integer number from 00 to 23. A 24-hour clock is used, so the earliest time in the day is 00:00 and the latest is 23:59.

Given two strings startTime and finishTime in the format "HH:MM" representing the exact time you started and finished playing the game, respectively, calculate the number of full rounds that you played during your game session.

For example, if startTime = "05:20" and finishTime = "05:59" this means you played only one full round from 05:30 to 05:45. You did not play the full round from 05:15 to 05:30 because you started after the round began, and you did not play the full round from 05:45 to 06:00 because you stopped before the round ended.
If finishTime is earlier than startTime, this means you have played overnight (from startTime to the midnight and from midnight to finishTime).

Return the number of full rounds that you have played if you had started playing at startTime and finished at finishTime.

Constraints:

startTime and finishTime are in the format HH:MM.

00 <= HH <= 23

00 <= MM <= 59

startTime and finishTime are not equal.

#### Solutions :
  * [numberOfRounds.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numberOfRounds.py)
---

### Largest Odd Number in String <a name="largestOddNumber"></a>
#### Challenge :
You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string "" if no odd integer exists.

A substring is a contiguous sequence of characters within a string.

Constraints:

1 <= num.length <= 10^5

num only consists of digits and does not contain any leading zeros.

#### Solutions :
  * [largestOddNumber.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/largestOddNumber.py)
---

### Partition Equal Subset Sum <a name="canPartition"></a>
#### Challenge :
Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

Constraints:

1 <= nums.length <= 200

1 <= nums[i] <= 100

#### Solutions :
  * [canPartition.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/canPartition.py)
---

### Maximum Product Difference Between Two Pairs <a name="maxProductDifference"></a>
#### Challenge :
The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).

For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.

Return the maximum such product difference.

#### Solutions :
  * [maxProductDifference.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/maxProductDifference.py)
---

### Cyclically Rotating a Grid <a name="rotateGrid"></a>
#### Challenge :
[Read the problem description here](https://leetcode.com/problems/cyclically-rotating-a-grid/)

#### Solutions :
  * [rotateGrid.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/rotateGrid.py)
---

###  Unique Binary Search Trees II <a name="generateTrees"></a>
#### Challenge :
Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.

[Read the problem description here](https://leetcode.com/problems/unique-binary-search-trees-ii/)

#### Solutions :
  * [generateTrees.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/generateTrees.py)
---

###  Find Numbers with Even Number of Digits <a name="findNumbers"></a>
#### Challenge :
Given an array nums of integers, return how many of them contain an even number of digits.

#### Solutions :
  * [findNumbers.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findNumbers.py)
---

###  Merge Sorted Array <a name="merge"></a>
#### Challenge :
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

#### Solutions :
  * [merge.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/merge.py)
---

###  Remove Element <a name="removeElement"></a>
#### Challenge :
Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

#### Solutions :
  * [removeElement.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/removeElement.py)
---

###  Remove Linked List Elements <a name="removeElements"></a>
#### Challenge :
Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.

#### Solutions :
  * [removeElements.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/removeElements.py)
---

###  Add Minimum Number of Rungs <a name="addRungs"></a>
#### Challenge :
You are given a strictly increasing integer array rungs that represents the height of rungs on a ladder. You are currently on the floor at height 0, and you want to reach the last rung.

You are also given an integer dist. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is at most dist. You are able to insert rungs at any positive integer height if a rung is not already there.

Return the minimum number of rungs that must be added to the ladder in order for you to climb to the last rung.

#### Solutions :
  * [addRungs.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/addRungs.py)
---

###  Maximum Number of Words You Can Type <a name="canBeTypedWords"></a>
#### Challenge :
There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.

Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard.

#### Solutions :
  * [canBeTypedWords.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/canBeTypedWords.py)
---

###  Sum of Digits of String After Convert <a name="getLucky"></a>
#### Challenge :
You are given a string s consisting of lowercase English letters, and an integer k.

First, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z' with 26). Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total.

For example, if s = "zbax" and k = 2, then the resulting integer would be 8 by the following operations:

Convert: "zbax" ➝ "(26)(2)(1)(24)" ➝ "262124" ➝ 262124
Transform #1: 262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17
Transform #2: 17 ➝ 1 + 7 ➝ 8
Return the resulting integer after performing the operations described above.

#### Solutions :
  * [getLucky.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/getLucky.py)
---

###  Remove Duplicates from Sorted Array <a name="removeDuplicates"></a>
#### Challenge :
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

#### Solutions :
  * [removeDuplicates.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/removeDuplicates.py)
---

###  Check If N and Its Double Exist <a name="checkIfExist"></a>
#### Challenge :
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

#### Solutions :
  * [checkIfExist.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/checkIfExist.py)
  * [checkIfExist1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/checkIfExist1.py)
---

###  Linked List Cycle II <a name="detectCycle"></a>
#### Challenge :
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Notice that you should not modify the linked list.

 
#### Solutions :
  * [detectCycle1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/detectCycle1.py)
  * [detectCycle2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/detectCycle2.py)
---

###  Linked List Cycle <a name="hasCycle"></a>
#### Challenge :
Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Return true if there is a cycle in the linked list. Otherwise, return false.
#### Solutions :
  * [hasCycle1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/hasCycle1.py)
  * [hasCycle2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/hasCycle2.py)
---

###  Maximum Number of Weeks for Which You Can Work <a name="numberOfWeeks"></a>
#### Challenge :
There are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has.

You can work on the projects following these two rules:

Every week, you will finish exactly one milestone of one project. You must work every week.
You cannot work on two milestones from the same project for two consecutive weeks.
Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. Note that you may not be able to finish every project's milestones due to these constraints.

Return the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above.
#### Solutions :
  * [numberOfWeeks1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numberOfWeeks1.py)
  * [numberOfWeeks2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numberOfWeeks2.py)
  * [numberOfWeeks3.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numberOfWeeks3.py)
---

###  Check If String Is a Prefix of Array <a name="isPrefixString"></a>
#### Challenge :
Given a string s and an array of strings words, determine whether s is a prefix string of words.

A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length.

Return true if s is a prefix string of words, or false otherwise.
#### Solutions :
  * [isPrefixString1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/isPrefixString1.py)
  * [isPrefixString2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/isPrefixString2.py)
  * [isPrefixString3.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/isPrefixString3.cpp)
---

###  Remove Stones to Minimize the Total <a name="minStoneSum"></a>
#### Challenge :
You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:

Choose any piles[i] and remove floor(piles[i] / 2) stones from it.
Notice that you can apply the operation on the same pile more than once.

Return the minimum possible total number of stones remaining after applying the k operations.

floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).
#### Solutions :
  * [minStoneSum1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minStoneSum1.py)
  * [minStoneSum2.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/minStoneSum2.cpp)
---

###  Minimum Number of Swaps to Make the String Balanced <a name="minSwaps"></a>
#### Challenge :
You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.

A string is called balanced if and only if:

It is the empty string, or
It can be written as AB, where both A and B are balanced strings, or
It can be written as [C], where C is a balanced string.
You may swap the brackets at any two indices any number of times.

Return the minimum number of swaps to make s balanced.
#### Solutions :
  * [minSwaps1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minSwaps1.py)
  * [minSwaps2.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/minSwaps2.cpp)
---

###  Find the Duplicate Number <a name="findDuplicate"></a>
#### Challenge :
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.

You must solve the problem without modifying the array nums and uses only constant extra space.
#### Solutions :
  * [findDuplicate1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minSwaps1.py)
  * [findDuplicate2.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/findDuplicate2.cpp)
  * [findDuplicate3.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/findDuplicate3.cpp)
  * [findDuplicate4.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/findDuplicate4.cpp)
---

###  Number of Strings That Appear as Substrings in Word <a name="numOfStrings"></a>
#### Challenge :
Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word.

A substring is a contiguous sequence of characters within a string.
#### Solutions :
  * [numOfStrings.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numOfStrings.py)
  * [numOfStrings.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/numOfStrings.cpp)
---

###  Array With Elements Not Equal to Average of Neighbors <a name="rearrangeArray"></a>
#### Challenge :
ou are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.

More formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].

Return any rearrangement of nums that meets the requirements.
#### Solutions :
  * [rearrangeArray.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/rearrangeArray.py)
---

###  Minimum Non-Zero Product of the Array Elements <a name="minNonZeroProduct"></a>
#### Challenge :
You are given a positive integer p. Consider an array nums (1-indexed) that consists of the integers in the inclusive range [1, 2p - 1] in their binary representations. You are allowed to do the following operation any number of times:

Choose two elements x and y from nums.
Choose a bit in x and swap it with its corresponding bit in y. Corresponding bit refers to the bit that is in the same position in the other integer.
For example, if x = 1101 and y = 0011, after swapping the 2nd bit from the right, we have x = 1111 and y = 0001.

Find the minimum non-zero product of nums after performing the above operation any number of times. Return this product modulo 109 + 7.

Note: The answer should be the minimum product before the modulo operation is done.
#### Solutions :
  * [minNonZeroProduct.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minNonZeroProduct.py)
---

###  Check Permutation <a name="checkPermutation"></a>
#### Challenge :
Given two strings, write a method to decide if one is a permutation of the
other.
#### Solutions :
  * [CheckPermutation.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/CheckPermutation.py)
  * [CheckPermutation.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++\checkPermutation.cpp)
---

###  Minimize the Difference Between Target and Chosen Elements <a name="minimizeTheDifference"></a>
#### Challenge :
You are given an m x n integer matrix mat and an integer target.

Choose one integer from each row in the matrix such that the absolute difference between target and the sum of the chosen elements is minimized.

Return the minimum absolute difference.

The absolute difference between two numbers a and b is the absolute value of a - b.
#### Solutions :
  * [minimizeTheDifference.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minimizeTheDifference.py)
---

###  Find Greatest Common Divisor of Array <a name="findGCD"></a>
#### Challenge :
Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.

The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.
#### Solutions :
  * [findGCD.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findGCD.py)
---

###   Find Unique Binary String <a name="findDifferentBinaryString"></a>
#### Challenge :
Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.
#### Solutions :
  * [findDifferentBinaryString.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/findDifferentBinaryString.py)
---

###   Reverse First k Elements of Queue <a name="reverseKelements"></a>
#### Challenge :
Reverse First k Elements of Queue
#### Solutions :
  * [reverseKElements.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reverseKElements.py)
  * [reverseKElements.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/reverseKElements.cpp)
---

###   Reverse First k Elements of Queue <a name="reverseKelements"></a>
#### Challenge :
Reverse First k Elements of Queue
#### Solutions :
  * [reverseKElements.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reverseKElements.py)
  * [reverseKElements.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/reverseKElements.cpp)
---

###   Check Permutation <a name="checkPermutation"></a>
#### Challenge :
Given two strings, write a method to decide if one is a permutation of the
other.
#### Solutions :
  * [CheckPermutation.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/CheckPermutation.py)
---

###   Find the last true <a name="lastTrue"></a>
#### Challenge :
Find the last true in a binary array using binary search

#### Solutions :
  * [lastTrue.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/lastTrue.py)
---

: 

### Rotate Matrix <a name="RotateMatrix"></a>
#### Challenge :
Given an image represented by an NxN matrix, where each pixel in the image is 4
bytes, write a method to rotate the image by 90 degrees. Can you do this in place?
#### Solutions :
  * [matRotate.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/matRotate.py)
---

### String Compression <a name="StringCompression"></a>
#### Challenge :
Implement a method to perform basic string compression using the counts
of repeated characters. For example, the string aabcccccaaa would become a2blc5a3. If the
"compressed" string would not become smaller than the original string, your method should return
the original string. You can assume the string has only uppercase and lowercase letters (a - z).
#### Solutions :
  * [StringCompression.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/StringCompression.py)
---

"Given a binary tree, populate an array to represent its zigzag level order traversal.
You should populate the values of all nodes of the first level from left to right, then right to left for the next level, alternating in the same way for all levels."
'''

### Zigzag Traversal <a name="ZigzagTraversal"></a>
#### Challenge :
Given a binary tree, populate an array to represent its zigzag level order traversal.
You should populate the values of all nodes of the first level from left to right, then right to left for the next level, alternating in the same way for all levels.
#### Solutions :
  * [zigZagTraversal.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/zigZagTraversal.py)
---

### Reverse the order of words in a given string. <a name="Reversewords"></a>
#### Challenge :
Reverse the order of words in a given string.
#### Solutions :
  * [reverseSentense.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/reverseSentense.py)
---



### URLify <a name="URLify"></a>
#### Challenge :
Write a method to replace all spaces in a string with '%20'. You may assume that the string
has sufficient space at the end to hold the additional characters, and that you are given the "true"
length of the string. (Note: If implementing in Java, please use a character array so that you can
perform this operation in place.)
EXAMPLE
Input: "Mr John Smith    ", 13
Output: "Mr%20John%20Smith".
#### Solutions :
  * [urlify.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/urlify.cpp)
---

### Zero Matrix <a name="ZeroMatrix"></a>
#### Challenge :
Write an algorithm such that if an element in an MxN matrix is 0, its entire row and
column are set to 0.
#### Solutions :
  * [zeroMatrix.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/zeroMatrix.cpp)
---

### Return Kth to Last <a name="ReturnKth"></a>
#### Challenge :
Implement an algorithm to find the kth to last element of a singly linked list.
#### Solutions :
  * [returnKth2Last.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/returnKth2Last.cpp)
---


### Sum Lists <a name="SumLists"></a>
#### Challenge :
You have two numbers represented by a linked list, where each node contains a single
digit. The digits are stored in reverse order, such that the 1 's digit is at the head of the list. Write a
function that adds the two numbers and returns the sum as a linked list.
#### Solutions :
  * [sumLists.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/sumLists.cpp)
---

### Minimum Difference Between Highest and Lowest of K Scores <a name="minimumDifference"></a>
#### Challenge :
You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.

Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.

Return the minimum possible difference.
#### Solutions :
  * [minimumDifference.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minimumDifference.py)
---

### Find the Kth Largest Integer in the Array <a name="kthLargestNumber"></a>
#### Challenge :
You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.

Return the string that represents the kth largest integer in nums.

Note: Duplicate numbers should be counted distinctly. For example, if nums is ["1","2","2"], "2" is the first largest integer, "2" is the second-largest integer, and "1" is the third-largest integer.
#### Solutions :
  * [kthLargestNumber.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/kthLargestNumber.py)
---

### Minimal Tree <a name="MinimalTree"></a>
#### Challenge :
Given a sorted (increasing order) array with unique integer elements, write an algorithm
to create a binary search tree with minimal height.
#### Solutions :
  * [minimalBTree.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minimalBTree.py)
---

### Route Between Nodes <a name="RouteBetweenNodes"></a>
#### Challenge :
Given a directed graph, design an algorithm to find out whether there is a
route between two nodes.
#### Solutions :
  * [RouteBetweenNodes.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/RouteBetweenNodes.py)
---

### Palindrome <a name="Palindrome"></a>
#### Challenge :
Implement a function to check if a linked list is a palindrome.

#### Solutions :
  * [listPalindrome.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/listPalindrome.py)
---

### linked lists Intersection <a name="linkedlistsIntersection"></a>
#### Challenge :
Given two (singly) linked lists, determine if the two lists intersect. Return the
intersecting node. Note that the intersection is defined based on reference, not value. That is, if the
kth node of the first linked list is the exact same node (by reference) as the jth node of the second
linked list, then they are intersecting.
#### Solutions :
  * [listIntersection.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/listIntersection.py)
---

### Count Special Quadruplets <a name="countQuadruplets"></a>
#### Challenge :
Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that:

nums[a] + nums[b] + nums[c] == nums[d], and
a < b < c < d
#### Solutions :
  * [countQuadruplets.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/countQuadruplets.py)
---

### The Number of Weak Characters in the Game <a name="numberOfWeakCharacters"></a>
#### Challenge :
You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.

A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei.

Return the number of weak characters.
#### Solutions :
  * [numberOfWeakCharacters.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/numberOfWeakCharacters.py)
  * [numberOfWeakCharacters.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/numberOfWeakCharacters.cpp)
---

### Shuffle an Array of Integers <a name="ShuffleArray"></a>
#### Challenge :
Given an integer array of size n, create a program to recursively shuffle the array so no two elements remain next to each other. Do not use extra space in your solution.
#### Solutions :
  * [shuffle.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/shuffle.cpp)
---

### Maximum Product of the Length of Two Palindromic Subsequences <a name="ShuffleArray"></a>
#### Challenge :
Given a string s, find two disjoint palindromic subsequences of s such that the product of their lengths is maximized. The two subsequences are disjoint if they do not both pick a character at the same index.

Return the maximum possible product of the lengths of the two palindromic subsequences.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is palindromic if it reads the same forward and backward.
#### Solutions :
  * [maxProduct.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/maxProduct.py)
---

### Final Value of Variable After Performing Operations <a name="finalValueAfterOperations"></a>
#### Challenge :
There is a programming language with only four operations and one variable X:

++X and X++ increments the value of the variable X by 1.
--X and X-- decrements the value of the variable X by 1.
Initially, the value of X is 0.

Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.

Constraints:

1 <= operations.length <= 100
operations[i] will be either "++X", "X++", "--X", or "X--".

#### Solutions :
  * [finalValueAfterOperations.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/finalValueAfterOperations.py)
  * [finalValueAfterOperations.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/finalValueAfterOperations.cpp)
---

### Sum of Beauty in the Array <a name="sumOfBeauties"></a>
#### Challenge :
You are given a 0-indexed integer array nums. For each index i (1 <= i <= nums.length - 2) the beauty of nums[i] equals:

2, if nums[j] < nums[i] < nums[k], for all 0 <= j < i and for all i < k <= nums.length - 1.
1, if nums[i - 1] < nums[i] < nums[i + 1], and the previous condition is not satisfied.
0, if none of the previous conditions holds.
Return the sum of beauty of all nums[i] where 1 <= i <= nums.length - 2.

Constraints:

3 <= nums.length <= 105
1 <= nums[i] <= 105

#### Solutions :
  * [sumOfBeauties.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/sumOfBeauties.py)
  * [sumOfBeauties.cpp](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/C++/sumOfBeauties.cpp)
---

### Detect Squares <a name="DetectSquares"></a>
#### Challenge :
You are given a stream of points on the X-Y plane. Design an algorithm that:

Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.
Given a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area.
An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.

Implement the DetectSquares class:

DetectSquares() Initializes the object with an empty data structure.
void add(int[] point) Adds a new point point = [x, y] to the data structure.
int count(int[] point) Counts the number of ways to form axis-aligned squares with point point = [x, y] as described above.

Constraints:

point.length == 2
0 <= x, y <= 1000
At most 5000 calls in total will be made to add and count.

#### Solutions :
  * [DetectSquares.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/DetectSquares.py)
---

### Maximum Difference Between Increasing Elements <a name="maximumDifference"></a>
#### Challenge :
Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 <= i < j < n and nums[i] < nums[j].

Return the maximum difference. If no such i and j exists, return -1.
#### Solutions :
  * [maximumDifference.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/maximumDifference.py)
---

### Grid Game <a name="gridGame"></a>
#### Challenge :
You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.

Both robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).

At the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.

The first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.
#### Solutions :
  * [gridGame.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/gridGame.py)
---

### Check if Numbers Are Ascending in a Sentence <a name="areNumbersAscending"></a>
#### Challenge :
A sentence is a list of tokens separated by a single space with no leading or trailing spaces. Every token is either a positive number consisting of digits 0-9 with no leading zeros, or a word consisting of lowercase English letters.

For example, "a puppy has 2 eyes 4 legs" is a sentence with seven tokens: "2" and "4" are numbers and the other tokens such as "puppy" are words.
Given a string s representing a sentence, you need to check if all the numbers in s are strictly increasing from left to right (i.e., other than the last number, each number is strictly smaller than the number on its right in s).

Return true if so, or false otherwise.

Constraints:

3 <= s.length <= 200
s consists of lowercase English letters, spaces, and digits from 0 to 9, inclusive.
The number of tokens in s is between 2 and 100, inclusive.
The tokens in s are separated by a single space.
There are at least two numbers in s.
Each number in s is a positive number less than 100, with no leading zeros.
s contains no leading or trailing spaces.

#### Solutions :
  * [areNumbersAscending.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/areNumbersAscending.py)
---

### Count Number of Maximum Bitwise-OR Subsets <a name="countMaxOrSubsets"></a>
#### Challenge :
Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.

An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.

The bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed). 
#### Solutions :
  * [countMaxOrSubsets.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/countMaxOrSubsets.py)
---

### Simple Bank System <a name="SimpleBankSystem"></a>
#### Challenge :
You have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). The bank has n accounts numbered from 1 to n. The initial balance of each account is stored in a 0-indexed integer array balance, with the (i + 1)th account having an initial balance of balance[i].

Execute all the valid transactions. A transaction is valid if:

The given account number(s) are between 1 and n, and
The amount of money withdrawn or transferred from is less than or equal to the balance of the account.
Implement the Bank class:

Bank(long[] balance) Initializes the object with the 0-indexed integer array balance.
boolean transfer(int account1, int account2, long money) Transfers money dollars from the account numbered account1 to the account numbered account2. Return true if the transaction was successful, false otherwise.
boolean deposit(int account, long money) Deposit money dollars into the account numbered account. Return true if the transaction was successful, false otherwise.
boolean withdraw(int account, long money) Withdraw money dollars from the account numbered account. Return true if the transaction was successful, false otherwise. 
#### Solutions :
  * [SimpleBankSystem.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/SimpleBankSystem.py)
---

### Number of Valid Words in a Sentence <a name="countValidWords"></a>
#### Challenge :
A sentence consists of lowercase letters ('a' to 'z'), digits ('0' to '9'), hyphens ('-'), punctuation marks ('!', '.', and ','), and spaces (' ') only. Each sentence can be broken down into one or more tokens separated by one or more spaces ' '.

A token is a valid word if:

It only contains lowercase letters, hyphens, and/or punctuation (no digits).
There is at most one hyphen '-'. If present, it should be surrounded by lowercase characters ("a-b" is valid, but "-ab" and "ab-" are not valid).
There is at most one punctuation mark. If present, it should be at the end of the token.
Examples of valid words include "a-b.", "afad", "ba-c", "a!", and "!".

Given a string sentence, return the number of valid words in sentence.
#### Solutions :
  * [countValidWords.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/countValidWords.py)
---

### Next Greater Numerically Balanced Number <a name="nextBeautifulNumber"></a>
#### Challenge :
An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x.

Given an integer n, return the smallest numerically balanced number strictly greater than n.
#### Solutions :
  * [nextBeautifulNumber.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/nextBeautifulNumber.py)
---

### Count Nodes With the Highest Score <a name="countHighestScoreNodes"></a>
#### Challenge :
There is a binary tree rooted at 0 consisting of n nodes. The nodes are labeled from 0 to n - 1. You are given a 0-indexed integer array parents representing the tree, where parents[i] is the parent of node i. Since node 0 is the root, parents[0] == -1.

Each node has a score. To find the score of a node, consider if the node and the edges connected to it were removed. The tree would become one or more non-empty subtrees. The size of a subtree is the number of the nodes in it. The score of the node is the product of the sizes of all those subtrees.

Return the number of nodes that have the highest score.
#### Solutions :
  * [countHighestScoreNodes.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/countHighestScoreNodes.py)
---

### Smallest Index With Equal Value <a name="smallestEqual"></a>
#### Challenge :
Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.

x mod y denotes the remainder when x is divided by y.
#### Solutions :
  * [smallestEqual.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/smallestEqual.py)
---

### Find the Minimum and Maximum Number of Nodes Between Critical Points <a name="nodesBetweenCriticalPoints"></a>
#### Challenge :
A critical point in a linked list is defined as either a local maxima or a local minima.

A node is a local maxima if the current node has a value strictly greater than the previous node and the next node.

A node is a local minima if the current node has a value strictly smaller than the previous node and the next node.

Note that a node can only be a local maxima/minima if there exists both a previous node and a next node.

Given a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any two distinct critical points and maxDistance is the maximum distance between any two distinct critical points. If there are fewer than two critical points, return [-1, -1].
#### Solutions :
  * [nodesBetweenCriticalPoints.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/nodesBetweenCriticalPoints.py)
---

### Minimum Operations to Convert Number <a name="minimumOperations"></a>
#### Challenge :
You are given a 0-indexed integer array nums containing distinct numbers, an integer start, and an integer goal. There is an integer x that is initially set to start, and you want to perform operations on x such that it is converted to goal. You can perform the following operation repeatedly on the number x:

If 0 <= x <= 1000, then for any index i in the array (0 <= i < nums.length), you can set x to any of the following:

x + nums[i]
x - nums[i]
x ^ nums[i] (bitwise-XOR)
Note that you can use each nums[i] any number of times in any order. Operations that set x to be out of the range 0 <= x <= 1000 are valid, but no more operations can be done afterward.

Return the minimum number of operations needed to convert x = start into goal, and -1 if it is not possible.
#### Solutions :
  * [minimumOperations.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/minimumOperations.py)
---

### Check if an Original String Exists Given Two Encoded Strings <a name="possiblyEquals"></a>
#### Challenge :
An original string, consisting of lowercase English letters, can be encoded by the following steps:

Arbitrarily split it into a sequence of some number of non-empty substrings.
Arbitrarily choose some elements (possibly none) of the sequence, and replace each with its length (as a numeric string).
Concatenate the sequence as the encoded string.
For example, one way to encode an original string "abcdefghijklmnop" might be:

Split it as a sequence: ["ab", "cdefghijklmn", "o", "p"].
Choose the second and third elements to be replaced by their lengths, respectively. The sequence becomes ["ab", "12", "1", "p"].
Concatenate the elements of the sequence to get the encoded string: "ab121p".
Given two encoded strings s1 and s2, consisting of lowercase English letters and digits 1-9 (inclusive), return true if there exists an original string that could be encoded as both s1 and s2. Otherwise, return false.

Note: The test cases are generated such that the number of consecutive digits in s1 and s2 does not exceed 3.
#### Solutions :
  * [possiblyEquals.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/possiblyEquals.py)
---

### Find Smallest Letter Greater Than Target <a name="nextGreatestLetter"></a>
#### Challenge :
Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.

Note that the letters wrap around.

For example, if target == 'z' and letters == ['a', 'b'], the answer is 'a'.
#### Solutions :
  * [nextGreatestLetter1.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/nextGreatestLetter1.py)
  * [nextGreatestLetter2.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/nextGreatestLetter2.py)
  * [nextGreatestLetter3.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/nextGreatestLetter3.py)
---

### Find Smallest Letter Greater Than Target <a name="isPerfectSquare"></a>
#### Challenge :
Given a positive integer num, write a function which returns True if num is a perfect square else False.

Follow up: Do not use any built-in library function such as sqrt.
#### Solutions :
  * [isPerfectSquare.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/isPerfectSquare.py)
---

### Deepest Leaves Sum <a name="deepestLeavesSum"></a>
#### Challenge :
Given the root of a binary tree, return the sum of values of its deepest leaves.

#### Solutions :
  * [deepestLeavesSum.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/deepestLeavesSum.py)
---

### Path Sum <a name="hasPathSum"></a>
#### Challenge :
Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.

A leaf is a node with no children.
#### Solutions :
  * [hasPathSum.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/hasPathSum.py)
---

### Dogs and Cats <a name="dogs_and_cats"></a>
#### Challenge :
You work for an animal shelter and you are responsible for feeding the animals. You already prepared D portions of dog food and C portions of cat food.

There are a total of N animals waiting in a line, some of which are dogs and others are cats. It might be possible that all the animals in the line are dogs or all the animals are cats. A string S of N characters C and D represents the order of cats and dogs in the line. The i-th character is equal to C if the i-th animal in the line is a cat. Similarly, the i-th character is equal to D if the i-th animal in the line is a dog.

The animals are fed in the order they stay in the line. Each dog eats exactly 1 portion of dog food and similarly each cat eats exactly 1 portion of cat food. Moreover, you have extra portions of cat food. Every time a dog eats food, you bring M extra portions of cat food for cats.

Animals have to be fed in the order they wait in line and an animal can only eat if the animal before it has already eaten. That means that if you run out of dog (or cat) food portions and a dog (or a cat) is about to get fed, the line will not move, as all the animals will wait patiently.

You need to determine if in this scenario all the dogs in the line will be fed. Note that this means that some cats might remain in the line, but worry not, you will eventually feed them later!

Input
The first line of the input gives the number of test cases, T. T test cases follow.

The first line of each test case contains four integers N, D, C, and M: the number of animals, the initial number of dog food portions, the initial number of cat food portions, and the additional portions of cat food that we add after a dog eats a portion of dog food, respectively.

The next line contains a string S of length N representing the arrangement of animals.

Output
For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is YES if all the dogs will be fed and NO otherwise.
#### Solutions :
  * [dogs_and_cats.py](https://github.com/vikumsw/Algorithms_For_Problem_Solving/blob/master/src/main/python/dogs_and_cats.py)
---